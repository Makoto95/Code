学籍番号03−160441　土屋潤一郎

1. 完成したプログラム
  ソースコードを添付いたします。

2. プログラムの簡単な説明
2.1.全体の流れ
  全体としては，まず前半の単語をカウントしながらリスト化し，次に後半の単語を，まず前半の単語リストの中に一致するものがないか確認し，一致していたら前半の単語の方のフラグを折る，一致するものがなかったら前半と同じ手順でリストに加え，あるいはカウントする．
  次いで，単語リストを前後半それぞれクイックソートで並び替え，数が多い順に標準出力に表示する，ということになる．
2.2.文字列探索とデータ構造
1.パターンが複数ある．
  そこで重要になるのは，単語の一致判定にどのような手法を用いるのかと，そこから決定される単語リストのデータ構造をどのようなものにするのかである．
  今回の課題で，文字列探索について考慮すべき条件として，
  2.パターン数が増加していく．
  3.複数のパターンの文字列長が固定ではない．
  4.パターンの中に，極端に短い文字列が存在しうる．
  などがあり，特に条件2や条件4などは条件1に対する効果的なアルゴリズムの効率を下げる要因になりうるので，今回は単にチェインハッシュ法を用いることにした．但し，（ハッシュリストの長さで割った余りを採用するなどで）ハッシュを一つだけ計算するのではなくて，データ構造にはまず（素数 * 素数 * 素数）の形の構造体の3次元配列を用意し，ハッシュのベースとなる数を3つの素数でそれぞれ割った余りをハッシュとして用いて，キーである文字列を格納していくことにした．
  構造体のメンバとして同様の構造体へのポインタが含まれており，3つのハッシュが全て衝突したときは，配列のその番地から単連結リストを伸ばしていくことになる．
  最初にポインタの配列を用意するのでなく構造体の配列を用意したのは，時間のかかる動的なメモリ確保（とそれに伴うメモリアクセスの時間増大）を出来るだけ減らしたかったからである．
2.3.ソート
 次に重要になるのは，数の多い単語への並び替えである．
 今回はクイックソートを採用した．
 なぜなら，今回注目スべき点として，数が多い順に5つが確実になればよいのであって全てを並び替える必要はない，という点がある．
 従ってクイックソートを用いれば，再帰の階層を潜って行く時に，分割した範囲がある程度の小ささになるまで，2つに分割した小さい方の範囲のソートをしなくて良い．それだけ計算回数が少なくて済むということである．

3.構造体と主な変数と関数
3.1.struct element (element_t)
  単語に関する情報を保持する構造体である．
  メンバには単語そのもの（文字列）と単語の出現回数の他に，前半の単語で，後半にもその単語が出現したかどうか（その前半の単語をソートに含めるかどうか）を表すフラグと，その構造体が動的に確保されたものかどうかの情報を保持しておくフラグ（これはメモリを解放するときに用いる），及び単方向連結リストのための次の構造体へのポインタが含まれている．
3.2.elementInit
  コンストラクタチックな，構造体の初期化関数である．
3.3.fhIndex[][][], lhIndex[][][]
  それぞれ，前半及び後半の単語リストである．
  3次元の構造体配列で，3つのハッシュと番地が対応する．
3.4.wordLen
  現在読み取っている単語の長さである．getWord関数で取得される．
 3.5.getWord
  テキストの中から単語を切り出してくる関数．
  但し，文字列そのものを返り値とするのではなく，関数の中で単語の最初の文字の場所， 最後の文字の場所，読み終わった文字の場所を代入し，単語の長さを返すことで，テキストの何文字目から何文字目までが単語に該当するのか，呼び出されるたびに先に進みながら調べていく関数となっている．
3.6.hashbase, hash1st, hash2nd, hash3rd
  ハッシュのベースとなる整数と，それを3つの素数で割った余りであるところのハッシュ値である．
3.7.getHash
  getWordの結果を受けて，ハッシュのベースとなる整数を返す関数．
3.8.wordcmp，wordcpy
  大文字と小文字の違いを無視しなければならないため，既存のstrcmpとstrcpyが使用できなかったので，その代替を自ら実装した．
3.9.storeWord
  wordcpyを用いて新たに単語リストに単語を追加する関数．
3.10.searchAndFlagIndex
  テキスト後半を読み取っている際，単語ごとにその単語が前半に出現しているか調べる関数．
  出現していた場合は，関数の中で前半側の単語のフラグを折ることまで行う．
3.11.q_sort
  再帰を用いてクイックソートを行う関数．前述のように，対象となる範囲の要素数が300未満になるまで小さい方の範囲のソートを捨てて，高速化を図っている．

4.コンパイル・実行と出力結果
  $ gcc 03160441report.c
  $ ./a.out < 2016.txt
  first half
  1. thou	5358
  2. thee	3108
  3. exeunt	1061
  4. hast	588
  5. thine	412
  last half
  1. holmes	2930
  2. mr	1736
  3. watson	1024
  4. don't	470
  5. sherlock	403

  time: 253 ms
