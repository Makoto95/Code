まず最初にすることは、パターンの最小の長さ（これをmとします。）を計算し、各パターンの最初のm個の文字だけを検討しています。
言い換えれば、我々は、全てのパターンが同じ長さを有するという必要条件を課します。
この必要条件は、アルゴリズムの効率性に不可欠であることが判明しました。
パターンのいずれかが非常に短い場合、例えば長さが2の場合には、我々は2より大きくシフトすることはありません。つまり短いパターンを有することは本質的にこのアプローチの効率性を損なうことに注意してください。

テキストから1文字ずつ見ていく代わりに、我々はサイズBのブロックでそれらを考慮します。
すべてのパターンの合計のサイズをMとすると、M = k*mで、アルファベットのサイズをcとしましょう。
3.1節で示すように、Bの良い値はlog_c(2M)のオーダーです。
実際には、我々は、B = 2またはB = 3のいずれかを使用します。
SHIFTテーブルは、たった1文字ではなく最後のB文字に基づいて、シフトを決定することを除いて、普通のボイヤー - ムーアのアルゴリズムと同じ役割を果たしています。
例えば、テキスト中のB文字の文字列がパターンのいずれかの中に現れない場合、その後、我々は、m-B+1によってシフトすることができます。
今、SHIFTテーブルがサイズBの各可能な文字列からのエントリを含むことを仮定しましょう。すると、その大きさは|Σ|^Bです。
（私たちは、実際には、スペースを節約するために、同じエントリにマッピングされた複数の文字列で圧縮されたテーブルを使用します。）
サイズBの各文字列は、SHIFTテーブルへのインデックスとして使用される整数に（後述するハッシュ関数を使用して）マッピングされています。
SHIFTテーブルの値は、我々はテキストをスキャンしている間、どのくらい前方にシフト（スキップ）することができるかを決定します。
テキスト中の現在スキャンしているB文字をX = x_1...x_Bとしましょう。そのXがSHIFTのi番目のエントリにマッピングされていると仮定しましょう。
2つの場合があります。

1.XがPのどのパターンの中の文字列としても表れない場合
この場合は、明らかに、テキスト中でm-B+1文字シフトすることが出来ます。
これより短いシフトは、不一致であるパターンの一つの部分に、テキストの最後のB文字を打ちます。
SHIFT[i]にはm-B+1を格納します。

2.Xがいくつかのパターンの中に表れる場合
この場合では、パターンのいずれかでXの右端の発生を見つけます。
XがPjの位置qで終了し、Xが他のパターンでのqよりも大きい任意の位置で終了していないと仮定しましょう。
SHIFT[i]にはm-qを格納します。
